<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>C programming language recap | Adam Yan Na Blog</title>
<meta name="generator" content="Jekyll v4.3.2">
<meta property="og:title" content="C programming language recap">
<meta name="author" content="Teddy">
<meta property="og:locale" content="en_US">
<meta name="description" content="C recap">
<meta property="og:description" content="C recap">
<link rel="canonical" href="http://localhost:4000/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AF%AD%E8%A8%80/c&amp;c++/2020/03/16/c-programming-language-recap.html">
<meta property="og:url" content="http://localhost:4000/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AF%AD%E8%A8%80/c&amp;c++/2020/03/16/c-programming-language-recap.html">
<meta property="og:site_name" content="Adam Yan Na Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-03-16T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="C programming language recap">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Teddy"},"dateModified":"2020-03-16T00:00:00+08:00","datePublished":"2020-03-16T00:00:00+08:00","description":"C recap","headline":"C programming language recap","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AF%AD%E8%A8%80/c&c++/2020/03/16/c-programming-language-recap.html"},"url":"http://localhost:4000/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AF%AD%E8%A8%80/c&c++/2020/03/16/c-programming-language-recap.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="http://localhost:4000">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Adam Yan Na Blog">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css" rel="stylesheet">
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = ``.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Adam Yan Na Blog" src="" onerror="this.style.display='none'">
  Adam Yan Na Blog
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">C programming language recap</h1>
  <h2 class="post-subtitle"></h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2020-03-16T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 16, 2020
    </time><span class="post-author left-vsplit"><i class="fa fa-pencil"></i> Teddy</span>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 14 mins</span>
  </div>
<div class="post-tags"><a class="post-tag" href="/tags.html#C&amp;C++">#C&amp;C++</a></div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h1 id="c-recap">C recap</h1>

<h6 id="this-file-is-a-recap-of-programming-language-c-prepare-for-c-learning">This file is a recap of programming language C, prepare for C++ learning</h6>

<pre><code class="language-C">#include &lt;stdio.h&gt;  // 引入包含头文件

int main() {	// main 是程序执行的开始
	printf("%s\n", "shit happens");

	return 1;
}
</code></pre>

<h3 id="通用高级语言为unix操作系统设计以b语言为基础">通用高级语言，为Unix操作系统设计，以B语言为基础</h3>

<ul>
  <li>结构化</li>
  <li>处理底层活动</li>
  <li>C11，ISO标准</li>
</ul>

<blockquote>
  <p>/* GCC
c源代码经过编译转为机器语言（CPU指令）
免费开源的编译器GNU的C/C++编译器
https://gcc.gnu.org/
https://github.com/gcc-mirror/gcc
https://zh.wikipedia.org/wiki/GCC</p>
</blockquote>

<blockquote>
  <p>The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Ada, Go, and D, as well as libraries for these languages (libstdc++,…). GCC was originally written as the compiler for the GNU operating system. The GNU system was developed to be 100% free software, free in the sense that it respects the user’s freedom.”GNU’s Not Unix!”</p>
</blockquote>

<blockquote>
  <p>gcc-core、gcc-g++、binutils
gcc、g++、ar、ranlib、dlltool</p>
</blockquote>

<blockquote>
  <p>编译原理
LLVM GCC CLANG</p>
</blockquote>

<blockquote>
  <p>GNU make
https://hacker-yhj.github.io/resources/gun_make.pdf
https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make
https://www.gnu.org/software/make/</p>
</blockquote>

<h3 id="c程序">c程序</h3>

<ul>
  <li>
    <p>预处理函数指令</p>
  </li>
  <li>
    <p>函数</p>
  </li>
  <li>
    <p>变量</p>
  </li>
  <li>
    <p>语句&amp;表达式</p>
  </li>
  <li>
    <p>注释</p>

    <blockquote>
      <p>简单了解编译
gcc xxx.c 
生成 xxx.out 可执行文件
gcc x.c xx.c -o</p>
    </blockquote>
  </li>
</ul>

<h3 id="tokens">tokens</h3>

<ul>
  <li>分号</li>
  <li>注释</li>
  <li>识符 大写字母或小写字母或下划线开始，后面跟多个字母、下划线、数字</li>
  <li>关键字，保留关键字
    <ul>
      <li>auto	变量自动声明</li>
      <li>break 	跳出当前循环</li>
      <li>case	switch分支</li>
      <li>char	声明字符型变量或函数返回类型</li>
      <li>const	定义常量</li>
      <li>continue  从continue直接开始下一轮循环</li>
      <li>default		switch的默认分支</li>
      <li>do     循环语句执行体</li>
      <li>double		双精度浮点数声明		64比特	8个字节</li>
      <li>else	条件语句分支</li>
      <li>enum	声明枚举类型</li>
      <li>extern	声明变量或者函数再外部文件</li>
      <li>float	声明福鼎类型		32比特 4个字节</li>
      <li>for 	循环</li>
      <li>goto	无条件跳转</li>
      <li>if 		条件语句</li>
      <li>int		整形声明</li>
      <li>long	长整型声明</li>
      <li>register	声明寄存器变量</li>
      <li>return		返回</li>
      <li>short	短整形</li>
      <li>signed	声明有符号类型变量或者函数</li>
      <li>static	静态变量</li>
      <li>struct  声明结构体类型</li>
      <li>switch  开关条件语句</li>
      <li>typedef  给数据类型取别名</li>
      <li>unsigned  声明无符号类型变量或函数</li>
      <li>union     声明共用体类型</li>
      <li>void	声明 无返回或无参数 无类型指针</li>
      <li>volatile 	变量在执行中被隐含的改变</li>
      <li>while	循环条件语句</li>
      <li>_Bool</li>
      <li>_Complex</li>
      <li>_Imaginary</li>
      <li>inline</li>
      <li>restrict</li>
      <li>_Alignof</li>
      <li>_Atomic</li>
      <li>_Generic</li>
      <li>_Noreturn</li>
      <li>_Static_assert</li>
      <li>_Thread_local</li>
      <li>
    </li>
</ul>
  </li>
</ul>

<h3 id="数据类型类型决定了占用的存储空间详见体系结构">数据类型，类型决定了占用的存储空间（详见体系结构）</h3>

<ol>
  <li>基本类型：算数类型，包括整数类型和浮点类型</li>
  <li>枚举类型：算术类型，用来定义程序中“只能赋予其一定的离散整数值的变量”</li>
  <li>void类型：没有可用的值</li>
  <li>派生类型； 包括，指针类型、数组类型、结构类型、共用体类型和函数类型</li>
</ol>

<ul>
  <li>
    <p>数组类型和结构类型统称为聚合类型；</p>
  </li>
  <li>
    <p>函数类型指的是函数返回值的类型；</p>
  </li>
  <li>
    <p>整数类型</p>

    <ul>
      <li>
        <p>类型				存储大小			值范围	A为65  a为97</p>
      </li>
      <li>
        <p>char			1 byte			-128 到 127 或 0 到 255</p>
      </li>
      <li>
        <p>unsigned char	1 byte			0 到 255	    无负值的字符型</p>
      </li>
      <li>
        <p>signed char		1 byte			-128 到 127</p>
      </li>
      <li>
        <p>int				2 或 4 byte		-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 32比特位整型和64比特位整型</p>
      </li>
      <li>
        <p>unsigned int	2 或 4 byte		0 到 65,535 或 0 到 4,294,967,295	无负值的整型</p>
      </li>
      <li>
        <p>short			2 byte			-32,768 到 32,767	32比特位整型</p>
      </li>
      <li>
        <p>unsigned short	2 byte			0 到 65,535			无负值的短整型</p>
      </li>
      <li>
        <p>long			4 byte			-2,147,483,648 到 2,147,483,647		64比特位整型</p>
      </li>
      <li>
        <p>unsigned long	4 byte			0 到 4,294,967,295			无负值的长整型</p>

        <blockquote>
          <p>i686和x86_64中的存储大小不同，当前操作系统主要以x86_64为主</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>sizeof(type)</p>
  </li>
  <li>
    <p>用来获取某个对象或类型的存储字节大小</p>
  </li>
  <li>
    <p>printf() 函数</p>

    <ul>
      <li>
        <p>format – format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</p>
      </li>
      <li>
        <p>format 标签属性是 %[flags][width][.precision][length]specifier</p>

        <ul>
          <li>
            <p>格式化输出</p>

            <ul>
              <li>
                <p>%d 十进制有符号整数</p>
              </li>
              <li>
                <p>%u 十进制无符号整数</p>
              </li>
              <li>
                <p>%f 浮点数</p>
              </li>
              <li>
                <p>%s 字符串</p>
              </li>
              <li>
                <p>%c 单个字符</p>
              </li>
              <li>
                <p>%p 指针的值</p>
              </li>
              <li>
                <p>%e 指数形式的浮点数</p>
              </li>
              <li>
                <p>%x, %X 无符号以十六进制表示的整数</p>
              </li>
              <li>
                <p>%o 无符号以八进制表示的整数</p>
              </li>
              <li>
                <p>%g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</p>
              </li>
              <li>
                <p>%p 输出地址符</p>
              </li>
              <li>
                <p>%lu 32位无符号整数</p>
              </li>
              <li>
                <p>%llu 64位无符号整数</p>

                <blockquote>
                  <p>https://www.runoob.com/cprogramming/c-function-printf.html</p>
                </blockquote>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>浮点类型</p>

    <ul>
      <li>float		4 byte		1.2E-38 到 3.4E+38		6 位小数</li>
      <li>double		8 byte		2.3E-308 到 1.7E+308		15 位小数</li>
      <li>long double	16 byte		3.4E-4932 到 1.1E+4932	19 位小数</li>
      <li>%E 为以指数形式输出单、双精度实数</li>
    </ul>
  </li>
  <li>
    <p>void类型</p>

    <ul>
      <li>
        <p>指定没有可用值</p>
      </li>
      <li>
        <ol>
          <li>
            <p>函数返回为空
function define以 void开头</p>
          </li>
          <li>
            <p>函数参数为空
不接受参数的函数；</p>
          </li>
          <li>
            <p>指针指向void
类型为void <em>的指针代表对象的地址，指向void的地址，也就是</em>xx存储了void在内存中的地址；</p>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h3 id="c-变量">C 变量</h3>

<ul>
  <li>
    <p>定义：变量是程序可操作的存储区的名称；</p>
  </li>
  <li>
    <p>C中每个变量都有特定类型，类型决定了变量存储的大小和布局，该范围内的值都可用存储在内存中；</p>
  </li>
  <li>
    <p>变量的名称由字母+数字+下划线组成，以字母或者下划线开始，区分大小写；</p>

    <ul>
      <li>char 		一个字节，8bit</li>
      <li>int			整数时最自然的大小</li>
      <li>float		格式：1bit符号，8bit指数，23bit小数</li>
      <li>double		格式：1bit符号，11bit指数，52bit小数</li>
      <li>void  		类型缺失</li>
    </ul>
  </li>
  <li>
    <p>C 变量定义</p>

    <ul>
      <li>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储；</li>
      <li>变量定义指定一个数据类型，并包含给类型的一个或者多个变量列表</li>
      <li>type variable_list</li>
      <li>指定类型		变量名称列表</li>
    </ul>
  </li>
</ul>

<pre><code class="language-C">int i, j, k;
extern int a = 1, b = 2;
//不带初始化的定义：带有静态存储时间的变量会被隐式初始化为NULL （所有字节的值都为0），其他变量初始值时未定义的；
</code></pre>

<h3 id="c-变量声明">C 变量声明</h3>

<ul>
  <li>变量声明向编译器保证变量以指定的类型和名称存在；</li>
  <li>变量声明在编译时才有意义，在程序连接时编译器需要实际的变量声明；</li>
</ul>

<ol>
  <li>建立存储空间的变量声明，例如 int a</li>
  <li>不需要建立存储空间的变量声明，使用extern关键字声明比变量名而不定义它； extern int a，a被声明但是可能在其他文件中被定义；
    <ul>
      <li>除了extern的情况外，变量都是被定义的；</li>
      <li>使用extern在一个文件中声明，在另一个文件中引用才会定义；</li>
    </ul>
  </li>
</ol>

<pre><code class="language-C">extern int a;
int b;
</code></pre>

<h3 id="左值和右值-lvalues--rvalues">左值和右值 Lvalues  Rvalues</h3>

<ol>
  <li>左值 lvalue ： 指向内存位置的表达式被称为左值表达式，可用出现在赋值号的左边或者右边</li>
  <li>右值 rvalue ： 存储在内存中的某些地址的数值，只能出现在赋值号的右边；例如，存储在内存某个地址的一个8bit ASC字符
    <ul>
      <li>左值： 指向内存位置的表达式</li>
    </ul>
  </li>
</ol>

<h3 id="常量">常量</h3>

<ul>
  <li>常量，字面量；</li>
  <li>
    <p>值在定义后不能修改；</p>
  </li>
  <li>整数常量
    <ul>
      <li>十进制、八进制、十六进制的常量；</li>
      <li>前缀指定基数：0x或0X表示十六进制，0表示八进制，不带默认表示十进制；</li>
      <li>后缀U表示无符号整数（unsigned）</li>
      <li>后缀L表示长整数（long）</li>
      <li>后缀可用大写也可以小写；</li>
    </ul>
  </li>
  <li>浮点常量
    <ul>
      <li>整数部分、小数点、小数部分、指数部分组成；</li>
      <li>使用小数形式或者指数形式来表示</li>
      <li>指数符合e\E</li>
      <li>指数形式要包括小数点或者指数</li>
    </ul>
  </li>
  <li>字符常量
    <ul>
      <li>使用 ‘单引号’ 存储在char类型的变量里；指向内存地址的可操作区域的名称，指向内存地址的表达式</li>
      <li>转义符
        <ul>
          <li>\	\ 字符</li>
          <li>'	‘ 字符</li>
          <li>"	“ 字符</li>
          <li>\?	? 字符</li>
          <li>\a	警报铃声</li>
          <li>\b	退格键</li>
          <li>\f	换页符</li>
          <li>\n	换行符</li>
          <li>\r	回车</li>
          <li>\t	水平制表符</li>
          <li>\v	垂直制表符</li>
          <li>\ooo	一到三位的八进制数</li>
          <li>\xhh . . .	一个或多个数字的十六进制数</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>字符串常量
    <ul>
      <li>字符串在“双引号中”</li>
    </ul>
  </li>
  <li>常量定义
    <ul>
      <li>#define</li>
      <li>const</li>
      <li>代码规范：使用大写表示常量</li>
    </ul>
  </li>
</ul>

<pre><code class="language-C">#define identifier value; // 预处理定义  标识符  值

#define TIMEOUT 30;

const type variable = value; // 常量定于 	类型定义	  变量名称（指向内存可操作区）  变量值（可操作区存储该值)
</code></pre>

<h3 id="存储类">存储类</h3>

<ul>
  <li>存储类定义C中变量和函数的范围（可见性）和生命周期；</li>
  <li>放在所修饰的类型之前；
    <ul>
      <li>auto</li>
      <li>register</li>
      <li>static</li>
      <li>extern</li>
    </ul>
  </li>
  <li>
    <p>auto存储类</p>

    <ul>
      <li>是所有局部变量的默认存储类；</li>
    </ul>

    <pre><code class="language-C">{
	int m;
	auto int m; // 上面两个带有相同的存储类，auto只能用于函数内，只能修饰局部变量；
}
</code></pre>
  </li>
  <li>
    <p>register 存储类</p>

    <ul>
      <li>定义存储在寄存器中而不是RAM中的局部变量；</li>
      <li>变量的最大size为寄存器的size；</li>
      <li>通常为1个词，不能对它应用一元“&amp;” 运算符，因为变量没有内存位置</li>
    </ul>

    <pre><code class="language-C">{
	register int s; // 寄存器用于需要快速访问的变量，例如计数器
// 定义‘register’ 并不会绝对将变量存储在寄存器内，取决于硬件的实际限制；
}
</code></pre>
  </li>
  <li>
    <p>static 存储类</p>

    <ul>
      <li>编译器在程序生命周期内保持局部变量的存在，而不需要在每次进入和离开作用域时都进行创建和销毁；
static 修饰局部变量可用在函数调用之间保持局部变量的值；</li>
      <li>static 修饰符也可以用于全局变量，<strong>修饰全局变量时，会使得变量的作用域限制在声明它的文件中；</strong>
</li>
      <li>全局声明的一个static变量或者方法，可以被任何函数或者方法调用；前提时这些变量和方法与static全局变量在同一个文件中；</li>
    </ul>

    <pre><code class="language-C">static int c = 999; // 全局变量 - static 是默认的
  
void func1(void) {
	static int t = 1; // t 是函数func的局部变量，使用static后，该变量在函数第一次被调用时初始化，以后每次都不会在被重置；  // 在程序的生命周期内会永远保留该局部变量的值；
	t ++;
	printf("%d %d\n", t, c);
}
</code></pre>
  </li>
  <li>
    <p>extern 存储类</p>

    <ul>
      <li>extern 存储类用于提供一个全局变量的引用，全局变量被extern修饰后，在程序的所有文件都可见；
使用extern，对于无法初始化的变量（相同变量名称已经在其他文件中定义过，extern声明会直接声明定义过的这个变量的地址），会把变量名指向之前定义过的一个存储位置；</li>
      <li>多个文件中定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern来得到已经定义的变量或函数的引用（引用就是存储了变量地址的表达式，而指针变量是存储了变量地址的变量的地址的表达式）</li>
    </ul>

    <pre><code class="language-C">// main.c
  
#include &lt;stdio.h&gt;
  
int count;
extern void fun_from_another_file(void);  //声明外部函数，函数定义在其他文件中
  
int main(int argc, char const *argv[])
{
	/* 可以直接使用本文件定义的静态全局变量 count */
	return 0;
}
  
// 该文件中可以使用定义的外部全局函数
</code></pre>
  </li>
</ul>

<h3 id="运算符">运算符</h3>

<ul>
  <li>算数运算符</li>
  <li>关系运算符</li>
  <li>逻辑运算符</li>
  <li>位运算符</li>
  <li>赋值运算符</li>
  <li>
    <p>杂项运算符</p>
  </li>
  <li>
    <p>算数运算符</p>

    <ul>
      <li>
        <p>/	分子除以分母</p>
      </li>
      <li>
        <p>%	取模运算符，整除后的余数</p>
      </li>
      <li>
        <p>++	自增运算符，整数值增加 A++</p>
      </li>
      <li>
        <p>–	自减运算符，整数值减少 A–</p>
      </li>
    </ul>
  </li>
  <li>关系运算符
    <ul>
      <li>==	检查两个操作数的值是否相等，如果相等则条件为真。	(A == B) 为假。</li>
      <li>!=	检查两个操作数的值是否相等，如果不相等则条件为真。	(A != B) 为真。</li>
    </ul>
  </li>
</ul>

<blockquote>
  <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>	检查左操作数的值是否大于右操作数的值，如果是则条件为真。	(A &gt; B) 为假。

&lt;	检查左操作数的值是否小于右操作数的值，如果是则条件为真。	(A &lt; B) 为真。
=	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。	(A &gt;= B) 为假。
&lt;=	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。	(A &lt;= B) 为真。
</code></pre></div>  </div>
</blockquote>

<ul>
  <li>
    <p>逻辑运算符</p>

    <ul>
      <li>&amp;&amp;	称为逻辑与运算符。如果两个操作数都非零，则条件为真。	(A &amp;&amp; B) 为假。
* ||	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。	(A || B) 为真。</li>
      <li>!	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。	!(A &amp;&amp; B) 为真。</li>
    </ul>
  </li>
  <li>
    <p>位运算符</p>

    <ul>
      <li>
        <p>&amp;</p>

        <ul>
          <li>按位与操作，按二进制位进行”与”运算。运算规则：</li>
        </ul>
      </li>
    </ul>

    <table>
      <tbody>
        <tr>
          <td>*</td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>
        <p>按位或运算符，按二进制位进行”或”运算。运算规则：</p>
      </li>
      <li>

        <ul>
          <li>异或运算符，按二进制位进行”异或”运算。运算规则： 寄存器中的加法运算，就是用异或，“二进制的不进位相加”</li>
        </ul>
      </li>
      <li>
        <p>~</p>

        <ul>
          <li>
            <p>取反运算符，按二进制位进行”取反”运算。运算规则：一个有符号二进制数的补码形式。</p>

            <blockquote>
              <p>原码：原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
反码：正数的反码是其本身； 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.
补码：正数的补码就是其本身； 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html
机器中码的处理，体系结构</p>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>
        <p>«</p>

        <ul>
          <li>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</li>
        </ul>
      </li>
      <li>
        <p>&gt; &gt;</p>

        <ul>
          <li>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="赋值运算符">赋值运算符</h3>

<ul>
  <li>=	简单的赋值运算符，把右边操作数的值赋给左边操作数	C = A + B 将把 A + B 的值赋给 C</li>
  <li>+=	加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数	C += A 相当于 C = C + A</li>
  <li>-=	减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数	C -= A 相当于 C = C - A</li>
  <li>*=	乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数	C *= A 相当于 C = C * A</li>
  <li>/=	除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数	C /= A 相当于 C = C / A</li>
  <li>%=	求模且赋值运算符，求两个操作数的模赋值给左边操作数	C %= A 相当于 C = C % A</li>
  <li>«=	左移且赋值运算符	C «= 2 等同于 C = C « 2</li>
  <li>&gt;&gt;=	右移且赋值运算符	C »= 2 等同于 C = C » 2</li>
  <li>&amp;=	按位与且赋值运算符	C &amp;= 2 等同于 C = C &amp; 2</li>
  <li>^=	按位异或且赋值运算符	C ^= 2 等同于 C = C ^2
* |=	按位或且赋值运算符	C |= 2 等同于 C = C | 2</li>
</ul>

<h3 id="杂项运算符">杂项运算符</h3>

<ul>
  <li>sizeof()	返回变量的字节大小 	sizeof(a) 将返回 4，其中 a 是整数。
&amp;	返回变量的地址 取地址符	&amp;a; 将给出变量的实际地址。</li>
  <li>* 指向一个变量  指针变量声明	*a; 将指向一个变量。
? :	 三元表单式  条件表达式	如果条件为真 ? 则值为 X : 否则值为 Y   x == y ? return x : return y</li>
</ul>

<h3 id="运算符优先级">运算符优先级</h3>

<ul>
  <li>上到下 -&gt; 高到低
    <ul>
      <li>后缀 	() [] -&gt; . ++ - -  	从左到右</li>
      <li>一元 	+ - ! ~ ++ - - (type)* &amp; sizeof 	从右到左</li>
      <li>乘除 	* / % 	从左到右</li>
      <li>加减 	+ - 	从左到右</li>
      <li>移位 	« » 	从左到右</li>
      <li>关系 	&lt; &lt;= &gt; &gt;= 	从左到右</li>
      <li>相等 	== != 	从左到右</li>
      <li>位与 AND 	&amp; 	从左到右</li>
      <li>位异或 XOR 	^ 	从左到右 
* 位或 OR 	| 	从左到右</li>
      <li>逻辑与 AND 	&amp;&amp; 	从左到右 
* 逻辑或 OR 	|| 	从左到右</li>
      <li>条件 	?: 	从右到左 
* 赋值 	= += -= *= /= %=»= «= &amp;= ^= |= 	从右到左</li>
      <li>逗号 	, 	从左到右</li>
    </ul>
  </li>
</ul>

<h3 id="判断语句">判断语句</h3>

<ul>
  <li>if</li>
  <li>if  else</li>
  <li>嵌套if</li>
  <li>switch</li>
  <li>嵌套switch</li>
  <li>condition ? block1 : block2;</li>
</ul>

<pre><code class="language-C">if ()
{

}else {

}

switch () {
	case :
	case :
	default :

}

// case 关键字后面必须是一个整数，或者是结果为整数的表达式，但不能包含任何变量，
</code></pre>

<h3 id="循环">循环</h3>

<ul>
  <li>while</li>
  <li>for</li>
  <li>do while 循环,检查条件放在尾部while中</li>
  <li>break</li>
  <li>continue</li>
  <li>goto</li>
</ul>

<pre><code class="language-C">while (){

}

do
{
	/* code */
} while (/* condition */);

// 无限循环

for ( ; ; )
{
	/* code */
}
//  Ctrl + C 发送终止信号
</code></pre>

<h3 id="函数">函数</h3>

<ul>
  <li>每个函数包含一组执行特殊任务的语句</li>
  <li>声明：函数名称、返回类型、参数定义：函数主题</li>
  <li>内置函数</li>
  <li>function method</li>
</ul>

<pre><code class="language-C">return_type function_name( parameter list)
{
	body of functon
}
</code></pre>

<blockquote>
  <p>A parameter is a variable in a method definition.
 When a method is called, the arguments are the data you pass into the method’s parameters.
 Parameter is variable in the declaration of function.
 Argument is the actual value of this variable that gets passed to function.</p>
</blockquote>

<ul>
  <li>Argument：实参，函数调用时传入的实际参数，实际参数</li>
  <li>parameter：形参，函数定义时定义的参数名称，形式参数</li>
</ul>

<h3 id="函数调用">函数调用</h3>

<pre><code class="language-C">function_name(parameter1, parameter2)
</code></pre>

<ul>
  <li>传值调用	该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</li>
  <li>引用调用	通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</li>
  <li>C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</li>
</ul>

<blockquote>
  <p>函数调用，直接传入参数的过程为传值调用
函数调用，传入指针变量的过程为引用调用，形参为指向实参的地址的指针；</p>
</blockquote>

<h3 id="c-作用域规则">C 作用域规则</h3>

<ul>
  <li>作用域是程序中定义的变量所存在的区域</li>
</ul>

<ol>
  <li>函数或者块内部的局部变量</li>
  <li>所有函数外部的全局变量</li>
  <li>形式参数的函数参数定义中</li>
</ol>

<ul>
  <li>局部</li>
  <li>全局</li>
  <li>
    <p>形式</p>
  </li>
  <li>
    <p>局部</p>

    <ul>
      <li>某个函数或者块的内部声明的变量为“局部变量”</li>
      <li>只能被该函数或者该代码块使用</li>
      <li>auto存储类</li>
    </ul>
  </li>
  <li>
    <p>全局变量</p>

    <ul>
      <li>定义在函数的外部，程序顶部</li>
      <li>整个程序的生命周期内都有效</li>
      <li>在任意函数内部访问，可以使用static、extern存储类</li>
      <li>函数中，同名的局部变量和全局变量，函数会使用局部变量</li>
    </ul>
  </li>
  <li>
    <p>形式参数</p>

    <ul>
      <li>函数声明和函数定义时，定义的入参，为形式参数</li>
      <li>在函数内部也是局部变量</li>
    </ul>
  </li>
  <li>
    <p>初始化</p>

    <ul>
      <li>
        <p>系统不会初始化局部变量</p>
      </li>
      <li>
        <p>系统会自动对全局变量进行初始化</p>

        <table>
          <thead>
            <tr>
              <th>*</th>
              <th>int</th>
              <th>0</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td> </td>
              <td>char</td>
              <td>‘\0’</td>
            </tr>
            <tr>
              <td> </td>
              <td>float</td>
              <td>0</td>
            </tr>
            <tr>
              <td> </td>
              <td>double</td>
              <td>0</td>
            </tr>
            <tr>
              <td> </td>
              <td>pointer</td>
              <td>NULL</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<h3 id="c数组">C数组</h3>

<ul>
  <li>
    <p>存储一个固定大小的相同类型元组的有序集合</p>
  </li>
  <li>
    <p>通过索引访问元素</p>
  </li>
  <li>
    <p>声明数组</p>

    <pre><code class="language-C">type arrayName [arraySize] //一维数组，arraySize必须大于0
double a1[10]
char a2[10]
int a3[10]
char * a4[10]
</code></pre>
  </li>
  <li>
    <p>数组初始化</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>	<span class="c1">//初始化大小为{}之间的数目</span>
<span class="kt">int</span> <span class="n">a2</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>	<span class="c1">// 初始化大小为5，index0为1，index1为3</span>
<span class="n">a2</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>多维数组</p>

    <pre><code class="language-C">// 形式
type name[size1][size2]; //二维数组
type name[size1][size2][size3]; //三维数组
  
//二维数组初始化
int a[3][3] = {
    {1,2,3},
    {4,5,6},
    {7,8,9}
}
  
int a[3][3] = {
    1,2,3,4,5,6,7,8,9
}
</code></pre>
  </li>
  <li>
    <p>数组参数传递</p>

    <pre><code class="language-C">// 指针
void func(int *array){
      
}
  
// 形参传递拷贝
void func(int array[10]) {
      
}
  
void func(int array[]){
      
}
  
// 函数返回数组
int * func() {
      
}
</code></pre>
  </li>
  <li>
    <p>指针指向的数组</p>

    <ul>
      <li>数组名称： 指向数组中第一个元素的地址</li>
    </ul>

    <pre><code class="language-C">double a[8]; // a 存储的是 a[0] 元素的地址，也就是a指向&amp;a[0]
double * p;
p = balance;
// 数组名称作为指针是合法的
*(a + 4); // 使用间接访问运算符访问数组中的第5个元素，从a的地址向后4段地址 等同于 a[4]
*(p) *(p+1) *(p+2)；
</code></pre>
  </li>
</ul>

<h3 id="枚举-enum">枚举 enum</h3>

<ul>
  <li>基本数据类型</li>
</ul>

<blockquote>
  <p>基本、枚举、void、派生</p>
</blockquote>

<pre><code class="language-C">enum 枚举名 {枚举元素1,枚举元素2,枚举元素3...};

enum WEEK {  //定义了一个类型为 WEEK 的枚举类型
    MON = 1,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
};

enum WEEK w; // 定义了 WEEK 枚举类型的一个变量

enum WEEK {  // 同时定义了类型为 WEEK 的枚举类型，和变量week
    MON = 1,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
} week;


enum {  // 省略枚举名， 直接定义变量week
    MON = 1,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
} week;

int main() {
    for (week = MON; week &lt;= SUN; week ++) {
        printf("%d\n", week)
    }
}

// C中枚举为int 或者 unsigned int
</code></pre>

<ul>
  <li>
    <p>第一个枚举成员的默认值为整型0，后面每一个成员在前一个成员+1；</p>
  </li>
  <li>
    <p>可以在定义枚举的时候改变元素的值，其后的值还是会在前面的基础加1；</p>
  </li>
  <li>
    <p>通过枚举类型定义枚举变量，枚举类中的元素可以直接赋值给枚举变量；</p>
  </li>
  <li>
    <p>枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的，不能再定义与它们名字相同的变量。</p>
  </li>
  <li>
    <p>Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。</p>
  </li>
</ul>

<blockquote>
  <p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。</p>
</blockquote>

<p>枚举的元素的访问方式，是将枚举变量</p>

<ul>
  <li>它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用<code class="language-plaintext highlighter-rouge">&amp;</code>取得它们的地址。这就是枚举的本质。</li>
</ul>

<h3 id="指针">指针</h3>

<h3 id="函数指针">函数指针</h3>

<ul>
  <li>指向函数的指针变量</li>
</ul>

<pre><code class="language-C">typedef int (*func)(int,int);  //函数指针的声明

int (* funcP)(int) = &amp;anotherFunc; //声明一个函数指针，保持另一个函数的地址
</code></pre>

<ul>
  <li>回调函数
    <ul>
      <li>函数指针作为某个函数的参数</li>
      <li>回调函数：将”函数指针”作为参数传入新的函数，新的函数执行时某种条件触发后，调用传入的函数；</li>
    </ul>
  </li>
</ul>

<h3 id="字符串">字符串</h3>

<ul>
  <li>使用NULL字符 <strong>‘\0’</strong> 终止的一位<strong>字符数组</strong>
</li>
  <li>数组末尾存储了”空字符”，数组大小比存储的字符串大1</li>
</ul>

<pre><code class="language-C">char string[] = 'hello';
char string[] = {'h', 'e', 'l', 'l', 'o','\0'}; //C 编译器会在初始化数组时，自动把 '\0' 放在字符串的末尾
</code></pre>

<ul>
  <li>
    <p>字符串操作的函数</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">函数 &amp; 目的</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">
<strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
        </tr>
        <tr>
          <td style="text-align: left">
<strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
        </tr>
        <tr>
          <td style="text-align: left">
<strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
        </tr>
        <tr>
          <td style="text-align: left">
<strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>
        </tr>
        <tr>
          <td style="text-align: left">
<strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
        </tr>
        <tr>
          <td style="text-align: left">
<strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="结构体">结构体</h3>

<ul>
  <li>
    <p>允许存储不同类型的数据</p>
  </li>
  <li>
    <p>结构的定义，必须使用struct语句，struct语句定义了一个包含多个成员的<strong>新的数据类型</strong>；</p>

    <pre><code class="language-C">stuct tag {
    member-list
   	member-list
    ...
} variable-list;
  
// tag是结构体标签
// member-list 是标准的变量定义
// variable-list 结构变量，定义在结构的末尾，最后一个分后前，可以指定一个或多个结构变量；
// tag、member-list、variable-list 这 3 部分至少要出现 2 个
// 结构体类型、结构体变量、结构体成员
  
// 没有类型标签
struct
{
    int a;
    char b;
    double c;
} s1;
  
// 没有声明变量
struct SIMAPLE {
    int a;
    char b;
    double c;
};
  
// 声明结构体变量
struct SIMPLE t1, t2[10], *t3;
// 结构体SIMPLE变量，结构体SIMPLE变量赋值到t2数组索引10处，结构体SIMPLE指针类型变量
  
// 使用typedef 创建结构体类型
typedef struct
{
    int a;
    char b;
    double c;
} Simple2;
  
</code></pre>

    <ul>
      <li>结构体成员可以包含其他结构体；可以包含指向自己结构体类型的指针（链表，二叉树）；</li>
      <li>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明；</li>
    </ul>
  </li>
  <li>
    <p>结构体变量的初始化</p>

    <ul>
      <li>结构体成员变量可以在定义时指定初始值；</li>
    </ul>
  </li>
  <li>
    <p>访问结构成员</p>

    <ul>
      <li>
<strong>(.)</strong>, 成员访问运算符；来访问结构体的成员变量</li>
    </ul>
  </li>
  <li>
    <p>结构体作为函数参数</p>

    <ul>
      <li>指针类型传参或者变量类型传参</li>
    </ul>
  </li>
  <li>
    <p>指向结构体的指针</p>

    <pre><code class="language-C">struct NewStruct * s;
s = &amp;new1;
// 指针指向成员变量
s-&gt;title;
printf("%s\n", s-&gt;title)
</code></pre>
  </li>
  <li>
    <p>位域</p>

    <ul>
      <li>实现把一个字节的二进制bit划分为几个不同的区域，并且说明每个区域的位数；</li>
      <li>一个存储了指定比特数的成员变量的数据结构；</li>
      <li>每个域位有一个“域名”，允许按域名操作，实现把几个不同对象的二进制按照位域来表示；
        <ul>
          <li>例如，状态开关，一个比特来表示 0， 1</li>
          <li>读取非标准文件格式</li>
        </ul>
      </li>
    </ul>

    <pre><code class="language-C">struct 位域结构名称
{
    位域列表
};
  
struct B{
    int a:8;
    int b:4;
    int c:4;
}data;
// 类型B的变量data，共占用16比特，两个字节，域a占8位，域b占4位，域c占4位；
</code></pre>

    <ul>
      <li>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</li>
      <li>由于单个位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。</li>
      <li>位域可以是无名位域，这时它只用来作填充或调整位置。<strong>无名的位域是不能使用的</strong>；</li>
    </ul>
  </li>
  <li>
    <p>本质上是一种结构类型，成员按照二进制分配；</p>
  </li>
  <li>
    <p>使用</p>

    <ul>
      <li>
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>位域变量名.位域名
位域变量名-&gt;位域名
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="c-共用体">C 共用体</h3>

<ul>
  <li>
    <p>共用体，允许成员共用相同的内存位置，且成员可以是不同类型；但是任何时间只能有一个成员<strong>有值</strong></p>
  </li>
  <li>
    <p>共用体，提供了一种在同一段内存空间存储不同类型的值的方式；</p>
  </li>
  <li>
    <p>定义</p>

    <pre><code class="language-C">union [union tag] {
    member definition;
    member definition;
    ...
}[one or more union variables];
  
// union tag 是可选择，定义一个union类型
// 每个 member 都是标准的变量定义
// 定位的末尾可以指定多个共用体变量
  
// i f str
union Data
{
	int i;
	float f;
	char str[20];
} data;
  
// Data类型的共用体可以存储一个整数，一个浮点数，或者一个字符串；可以在共用体中使用自定的数据结构
// 共用体占用的内存要足够存储共用体中最大的成员
</code></pre>
  </li>
  <li>
    <p>访问共用体成员</p>

    <ul>
      <li>
<strong>(.)</strong>, 成员访问运算符；来访问共用体内部的成员</li>
      <li>同一时间只有一个成员能够存储值，其他成员会指向数据类型默认值；</li>
    </ul>
  </li>
</ul>

<p><a href="http://c.biancheng.net/cpp">C学习</a></p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/%E5%AE%9E%E8%B7%B5/%E7%A2%8E%E7%89%87%E8%83%B6%E5%9B%8A/2020/03/07/capsule.html" title="知识碎片">知识碎片</a><a class="next" href="/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2020/03/16/network-curve.html" title="计算机网络">计算机网络</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="">
          <a class="post-link" href="/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E5%BA%94%E7%94%A8/%E8%87%AA%E5%8A%A8%E5%8C%96/2020/05/14/ansible-automation.html" title="Ansible自动化">
            Ansible自动化<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/%E5%AE%9E%E8%B7%B5/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2020/07/12/git-advanced.html" title="Git进阶">
            Git进阶<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E8%AF%AD%E8%A8%80/python/2020/03/24/understanding-of-tornado.html" title="tornado框架学习及源码分析">
            tornado框架学习及源码分析<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/%E5%AE%9E%E8%B7%B5/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2020/01/08/Sum-of-2019-MonitorSystemArchitecture.html" title="SumOf2019 - MonitorSystemArchitecture">
            SumOf2019 - MonitorSystemArchitecture<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2023 Adam Yan Na</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
